# 作业三10.28
南子谦 信息与计算科学 3210104676
## 设计思路
在AvlTree中以printTree函数为基础，增加对key值大小的判断，public中创建一个printWantedTree函数，调用private中printWantedTree函数。
## 理论分析
对于该算法，可以理解为一次对平衡二叉树的遍历，而平衡二叉树的遍历本身时间复杂度为$O(logN)$，之后顺序输出$[k1,k2]$中的数，时间复杂度为$O(K)$，$K$为所需输出的数的个数，综合两部分即得该程序的时间复杂度为$O(K+logN)$。
当$K$比$logN$小一个数量级及以上时，此时输出时间$K$相较于寻找时间$logN$是一个可忽略的小数，程序主要用于遍历，即寻找大等于$k1$的最小数和小等于$k2$的最大数的位置，故此时程序时间复杂度为$O(logN)$；当$\frac{K}{N}$比较大，比较接近于1时，程序主要用于输出$k1$到$k2$之间的数，此时程序时间复杂度为$O(K)$。综上所述，该程序的时间复杂度为$O(K+logN)$。

## 数值结果分析
|                      |               |                |
|----------------------|---------------|----------------|
| n= 100;k1=1;k2=2;    | runtime:0.003 |                |
| n= 1000;k1=1;k2=2;   | runtime:0.001 | n占主导，k较小 |
| n= 10000;k1=1;k2=2;  | runtime:0     |                |
| n= 100k1=1k2=100     | runtime:0.023 |                |
| n= 1000k1=1k2=100    | runtime:0.029 | n占主导，k较大 |
| n= 10000k1=1k2=100   | runtime:0.02  |                |
| n= 1000k1=1k2=2      | runtime:0.001 |                |
| n= 1000k1=10k2=20    | runtime:0.002 | k占主导，n较小 |
| n= 1000k1=100k2=200  | runtime:0.021 |                |
| n= 10000k1=1k2=2     | runtime:0.008 | K占主导，n较大 |
| n= 10000k1=10k2=20   | runtime:0.002 |                |
| n= 10000k1=100k2=200 | runtime:0.022 | 0.022          |
---
从上面可以看出，当$logN$占主导地位时，运行时间随$N$的数量级增加增幅不大，运行时间基本符合复杂度$O(logN)$；当$K$占主导地位时，运行时间随$K$的数量级增加以同数量级增加，运行时间基本符合复杂度$O(K)$。故该程序的时间复杂度基本符合上述分析，即符合$O(K+logN)$。在$K$与$N$以同样的速度增长时，因$K$增长速度比$logN$快太多，故当$K$增长到一定程度时，基本是输出时间占程序运行时间的主要部分。